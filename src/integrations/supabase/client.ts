// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL ?? '';
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY ?? '';

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

const supabaseOptions = typeof window !== 'undefined' ? {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
} : undefined;

function createSafeStubClient() {
  const warn = () => console.warn("[supabase stub] Supabase client not initialized. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY for full functionality.");

  const asyncNoOp = async () => ({ data: null, error: null });

  return {
    auth: {
      onAuthStateChange: (cb: any) => {
        warn();
        // If a dev session exists, call the callback immediately to simulate auth state
        try {
          if (typeof window !== 'undefined') {
            const raw = localStorage.getItem('dev_supabase_session');
            const session = raw ? JSON.parse(raw) : null;
            // call callback with v2 signature (event, session)
            setTimeout(() => cb && cb('SIGNED_IN', session), 0);
          }
        } catch (e) {
          // ignore
        }
        return { data: { subscription: { unsubscribe: () => {} } } };
      },
      getSession: async () => {
        warn();
        try {
          if (typeof window !== 'undefined') {
            const raw = localStorage.getItem('dev_supabase_session');
            const session = raw ? JSON.parse(raw) : null;
            return { data: { session } };
          }
        } catch (e) {
          // ignore
        }
        return { data: { session: null } };
      },
      signOut: async () => {
        warn();
        try { if (typeof window !== 'undefined') localStorage.removeItem('dev_supabase_session'); } catch(e){}
        return { error: null };
      },
      // Newer supabase-js auth methods
      signInWithPassword: async ({ email, password }: { email: string, password: string }) => {
        warn();
        // emulate failure if empty
        if (!email || !password) return { error: new Error('Missing credentials'), data: null };
        // Check for dev-only credentials (only active in dev builds)
        try {
          if (typeof window !== 'undefined' && import.meta.env.DEV) {
            const DEV_EMAIL = import.meta.env.VITE_DEV_AUTH_EMAIL || 'dev@example.com';
            const DEV_PASS = import.meta.env.VITE_DEV_AUTH_PASSWORD || 'dev-password';
            if (email === DEV_EMAIL && password === DEV_PASS) {
              const user = { id: '00000000-0000-0000-0000-devsession', email };
              const session = { access_token: 'dev-token', expires_at: Math.floor(Date.now()/1000) + 3600, user };
              localStorage.setItem('dev_supabase_session', JSON.stringify(session));
              return { data: { session }, error: null };
            }
          }
        } catch (e) {
          // ignore
        }
        return { data: null, error: null };
      },
      signUp: async ({ email, password, options }: any) => {
        warn();
        if (!email || !password) return { error: new Error('Missing credentials'), data: null };
        return { data: null, error: null };
      },
      resend: async (_opts: any) => {
        warn();
        return { error: null };
      }
    },
    from: (_table: string) => {
      // chainable query builder stub
      const builder: any = {
        _table: _table,
        select(cols?: string) { this._select = cols; return this; },
        eq(field?: string, value?: any) { this._eq = { field, value }; return this; },
        order: function() { return this; },
        limit: function() { return this; },
        insert: async function(_data: any) { return { data: null, error: null }; },
        update: async function(_data: any) { return { data: null, error: null }; },
        delete: async function() { return { data: null, error: null }; },
        upsert: async function(_data: any) { return { data: null, error: null }; },
      };
      // make builder awaitable: await builder.select(...).eq(...)
      builder.then = function(resolve: any) { return resolve({ data: null, error: null }); };
      return builder;
    },
    rpc: async () => ({ data: null, error: null }),
    channel: (_name: string) => {
      const ch: any = {
        _name: _name,
        on(event?: any, opts?: any, callback?: any) {
          // allow both (event, opts, cb) and (event, cb)
          if (typeof opts === 'function') { callback = opts; opts = undefined; }
          // store handlers if needed
          (ch._handlers = ch._handlers || []).push({ event, opts, callback });
          return ch;
        },
        subscribe: async function() {
          // return object resembling real client
          return { data: { subscription: { unsubscribe: () => {} } } };
        },
        unsubscribe: async function() { return {}; }
      };
      return ch;
    }
  } as any;
}

export const supabase = (typeof window !== 'undefined' && SUPABASE_URL && SUPABASE_PUBLISHABLE_KEY)
  ? createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, supabaseOptions)
  : createSafeStubClient();
