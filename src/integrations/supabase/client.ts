// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

export const SUPABASE_URL = "https://kdpqimetajnhcqseajok.supabase.co";
export const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtkcHFpbWV0YWpuaGNxc2Vham9rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQwMDQxMTAsImV4cCI6MjA2OTU4MDExMH0.VkqXvocYAYO6RQeDaFv8wVrq2xoKKfQ8UVj41az7ZSk";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// Enhance functions.invoke with multi-fallback and detailed error reporting
try {
  const originalInvoke = (supabase.functions as any).invoke.bind(supabase.functions);
  (supabase.functions as any).invoke = async (name: string, options?: any) => {
    const body = options?.body ?? {};

    // Prepare headers BEFORE first attempt so the function receives correct auth/force flags
    const extraHeaders: Record<string, string> = { ...(options?.headers || {}) };
    try {
      const { data: sessionData } = await supabase.auth.getSession();
      const access = sessionData?.session?.access_token;
      if (access) {
        extraHeaders['Authorization'] = `Bearer ${access}`;
      }
      if (body?.force || name === 'create-tenant-account' || name === 'create-user-with-role') {
        // Always include force header for these flows to avoid anon-key-as-JWT issues
        extraHeaders['x-force-create'] = 'true';
      }
    } catch {}

    try {
      const result = await originalInvoke(name, { ...(options || {}), headers: { ...(options?.headers || {}), ...extraHeaders } });
      if (result?.error) throw result.error;
      return result;
    } catch (err: any) {
      // Try server proxy fallback using service role or anon
      try {
        const body = options?.body ?? {};
        const res = await fetch(`/api/edge/${name}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...extraHeaders },
          body: JSON.stringify(body)
        });
        const text = await res.text();
        let data: any; try { data = JSON.parse(text); } catch { data = text; }
        if (res.ok) {
          return { data, error: null } as any;
        } else {
          proxyFailedDetails = { status: res.status, details: data };
        }
      } catch (fallbackErr: any) {
        proxyFailedDetails = fallbackErr?.message || String(fallbackErr);
      }

      // 2) Direct call to Supabase Edge Function with publishable key
      try {
        const fnUrl = `${SUPABASE_URL.replace(/\/$/, '')}/functions/v1/${name}`;
        const res = await fetch(fnUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'apikey': SUPABASE_PUBLISHABLE_KEY,
            // Prefer user JWT if available; else use anon
            'Authorization': extraHeaders['Authorization'] || `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
            ...extraHeaders,
          },
          body: JSON.stringify(body)
        });
        const text = await res.text();
        let data: any; try { data = JSON.parse(text); } catch { data = text; }
        if (res.ok) {
          return { data, error: null } as any;
        } else {
          return { data: null as any, error: { message: 'Edge function fetch failed', status: res.status, details: data, proxyFailedDetails } };
        }
      } catch (directErr: any) {
        const parts: string[] = [];
        const e = directErr || err;
        if (e?.message) parts.push(e.message);
        if (e?.details) parts.push(e.details);
        if (e?.hint) parts.push(`hint: ${e.hint}`);
        if (proxyFailedDetails) parts.push(`proxy: ${typeof proxyFailedDetails === 'string' ? proxyFailedDetails : JSON.stringify(proxyFailedDetails)}`);
        return { data: null as any, error: { message: parts.join(' | ') || String(e) } };
      }
    }
  };

  // RPC fallback via proxy to bypass browser CORS
  const origRpc = (supabase as any).rpc.bind(supabase);
  (supabase as any).rpc = (fn: string, params?: any) => {
    // Helper that attempts the original RPC call and falls back to the proxy fetch
    const callOrig = async () => {
      try {
        const maybeBuilder = origRpc(fn, params);
        // If original returned a builder with chainable methods (maybeSingle/single), await its default execution
        if (maybeBuilder && typeof maybeBuilder.maybeSingle === 'function') {
          const res = await maybeBuilder;
          if (res?.error && String(res.error?.message || '').toLowerCase().includes('failed to fetch')) throw res.error;
          return res;
        }
        // If it's already a promise-like result, await it directly
        const res = await maybeBuilder;
        if (res?.error && String(res.error?.message || '').toLowerCase().includes('failed to fetch')) throw res.error;
        return res;
      } catch (err: any) {
        try {
          const { data: sessionData } = await supabase.auth.getSession();
          const access = sessionData?.session?.access_token;
          const r = await fetch(`/api/rpc/${encodeURIComponent(fn)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...(access ? { Authorization: `Bearer ${access}` } : {}) },
            body: JSON.stringify(params || {})
          });
          const text = await r.text();
          let data: any; try { data = JSON.parse(text); } catch { data = text; }
          if (r.ok) return { data, error: null };
          return { data: null, error: data?.error || data };
        } catch (e) {
          return { data: null, error: err || e };
        }
      }
    };

    // Build a wrapper that is both thenable (so `await supabase.rpc(...)` works)
    // and exposes common chain methods like maybeSingle/single by delegating to the original builder when possible.
    const wrapper: any = {
      maybeSingle: async () => {
        try {
          const possibleBuilder = origRpc(fn, params);
          if (possibleBuilder && typeof possibleBuilder.maybeSingle === 'function') {
            const res = await possibleBuilder.maybeSingle();
            if (res?.error && String(res.error?.message || '').toLowerCase().includes('failed to fetch')) throw res.error;
            return res;
          }
          return await callOrig();
        } catch (e) {
          return { data: null, error: e };
        }
      },
      single: async () => {
        try {
          const possibleBuilder = origRpc(fn, params);
          if (possibleBuilder && typeof possibleBuilder.single === 'function') {
            const res = await possibleBuilder.single();
            if (res?.error && String(res.error?.message || '').toLowerCase().includes('failed to fetch')) throw res.error;
            return res;
          }
          return await callOrig();
        } catch (e) {
          return { data: null, error: e };
        }
      },
      // Make wrapper thenable so `await supabase.rpc(...)` resolves to { data, error }
      then(resolve: any, reject: any) {
        return callOrig().then(resolve, reject);
      },
      catch(cb: any) {
        return callOrig().catch(cb);
      }
    };

    return wrapper;
  };
} catch {}
